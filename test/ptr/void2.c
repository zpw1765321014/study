#include <stdio.h>
#include <stdlib.h>
/*****************指针的测试
 * 深入学习 空指针 并且了解其相互转换
 * 指针有两个属性：指向变量/对象的地址和长度，但是指针只存储地址,长度则取决于指针的类型；
 * 编译器根据指针的类型从指针指向的地址向后寻址，指针类型不同则寻址范围也不同,比如:
 * int*     从指定地址向后寻找4字节作为变量的存储单元
     double*  从指定地址向后寻找8字节作为变量的存储单元
     void即“无类型”，void *则为“无类型指针”，可以指向任何数据类型。
 * */

/***************************************/
/*
  1 .void的作用
     对函数返回的限定
　　 当函数不需要返回值时，必须使用void限定。例如： void func(int, int)
    对函数参数的限定
　　当函数不允许接受参数时，必须使用void限定。例如： int func(void)

   2 .void指针使用规范
   2.1 void指针可以指向任意类型的数据，即可用任意数据类型的指针对void指针赋值。例如
   int  *pint   ；
    void *pvoid  ;      //它没有类型，或者说这个类型不能判断出指向对象的长度
    pvoid = pint ;      //只获得变量/对象地址而不获得大小,但是不能 pint =pvoid;

    2.6 void不能代表一个真实的变量
　　下面代码都企图让void代表一个真实的变量，因此都是错误的代码：

     void a            ; //错误
      function(void a)  ; //错误
*/
/*
   void体现了一种抽象，这个世界上的变量都是“有类型”的，譬如一个人不是男人就是女人（还有人妖？）。
　　void的出现只是为了一种抽象的需要，如果你正确地理解了面向对象中“抽象基类”的概念，
   也很容易理解void数据类型。正如不能给抽象基类定义一个实例，
    我们也不能定义一个void（让我们类比的称void为“抽象数据类型”）变量。
    由于void * 可以和任何指针直接做变换，除了函数指针外，在C编译器下，我们知道malloc函数的返回类型是void*，所以下2句是等价的
    int *p =(int*)malloc(100*sizeof(int));
     int *p =malloc(100*sizeof(int))
*/
/*******************************/
int main(void)
{
    int a = 100;
    int *p =(int*)malloc(sizeof(int));
     //int *p =malloc(sizeof(int));
     p = &a;
     printf("%p %d\n",p,*p);
     return 0;
}