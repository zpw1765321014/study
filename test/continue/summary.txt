1.什么么有协成    存在的必要性

   a.轻量级线程  
   b.io阻塞
   c.异步化


   int nready = epoll_wait(epfd,xxx ,length,-1);  //检查时间就绪 就绪事件包括可读可写

   recv();   //对IO数据进程读操作
   send();   //对IO数据进行写操作


  在同一个流程里面  这种方式是同步


  int nready = epoll_wait(epfd,xxx ,length,-1);  //检查时间就绪 就绪事件包括可读可写
  push_to_thread(); //给另外一个进程进行 处理  读写不在同一个流程里面   
  io 异步操作

  异步  0.8S 


  同步和异步是形容两者之间的关系


  同步/异步与协成有什么关系？


  同步的编程方式更加直观 ，性能不高

  同步的编程方式,异步的性能 （协成）

  一个请求 一个线程


  一个是jump--->pos  yield 让出操作
  一个是jump->back   resume 恢复操作


  CPU     线程1  切换保存  线程2 load  加载出来

  IO 密集型完全可以代替 线程

  如何定义：协成
     cpu_txt;
     status(ready,runing,defer);
     func() //回调函数
     arg ://对应的参数
     stack: 栈空间 协成拥有自己的独立的空间sp-->指向的位置 就是栈
     stack_size:栈的大小
     status:协成处于一个什么状态
     就绪集合的一个元素   队列 执行（就绪的时候）
     等待集合的一个元素   队列
     休眠就和的一个元素   红黑树

调度器:
      一个调度器 调度N多个协成  
    
    1.cur_txt;当前的那个协成
    2.集合存取 对应的状态 set<ready> set<defer>
    3.epoll  协成的驱动 IO的管理用epoll  实现
    


协成的执行流程，两条线
  1.通过nrygo 提供的api
  2.schedule_run 调度方法


//如果一个协成也没有调度器是没有意义的



//协成多核如何实现？
  
   1.线程的粘合
   2.进程的粘合

实现多核的话  协成 充分利用多核

  1.借助线程
    所有的线程 公用一个调度器
       出现线程之间 互跳
    每一个线程一个调度器

  2.借助进程
     
      每一个进程一个调取器  

  swoole 的协成是如何利用多核实现的呢?
 
  多进程模型实现的

  线程或者进程绑定CPU  是绑定到对应的 cpu对应的核心上 每次调度都 在这个CPU上执行